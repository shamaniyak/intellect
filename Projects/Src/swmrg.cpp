#include "swmrg.h"

CSWMRG::CSWMRG()
{

}

CSWMRG::~CSWMRG()
{

}

void CSWMRG::WaitToRead()
{
  // обеспечиваем монопольный доступ к переменным-членам
  m_cs.lock();
  // работает ли сейчас с ресурсом какой-нибудь поток-"писатель"
  // и есть ли "писатели", ждущие этот ресурс?
  bool fResourceWritePending = (m_nWaitingWriters || (m_nActive < 0));
  if (fResourceWritePending) {
    // этот "читатель" должен ждать,
    // увеличиваем счетчик числа ждущих "читателей" на 1
    m_nWaitingReaders++;
  } else {
    // этот "читатель" может читать,
    // увеличиваем счетчик числа активных "читателей" на 1
    m_nActive++;
  }
  // разрешаем другим потокам попытаться получить доступ для чтения или записи
  m_cs.unlock();

  if (fResourceWritePending) {
    // этот поток должен ждать
    m_hsemReaders.acquire();
  }
}

void CSWMRG::WaitToWrite()
{
  // обеспечиваем монопольный доступ к переменным-членам
  m_cs.lock();
  // работают ли сейчас с ресурсом какие-нибудь потоки?
  bool fResourceOwned = (m_nActive != 0);
  if (fResourceOwned) {
    // этот "писатель" должен ждать,
    // увеличиваем счетчик числа ждущих "писателей" на 1
    m_nWaitingWriters++;
  } else {
    // этот "писатель" может писать,
    // уменьшаем счетчик числа активных "писателей" до -1
    m_nActive = -1;
  }
  // разрешаем другим потокам попытаться получить доступ для чтения или записи
  m_cs.unlock();

  if (fResourceOwned) {
    // этот поток должен ждать
    m_hsemWriters.acquire();
  }
}

void CSWMRG::Done()
{
  // обеспечиваем монопольный доступ к переменным-членам
  m_cs.lock();

  if (m_nActive > 0) {
    // ресурс контролируют "читатели", значит, убираем одного из них так
    m_nActive--;
  } else {
    // ресурс контролируют "писатели", значит, убираем одного из них так
      m_nActive++;
  }

  QSemaphore *hsem = nullptr; // предполагаем, что ждущих потоков нет
  int lCount = 1; // предполагаем, что пробуждается только один ждущий поток
  // (в отношении "писателей" это всегда так)
  if (m_nActive == 0) {
    // Ресурс свободен, кого пробудить?
    // Примечание: "читатели" никогда не получат доступ к ресурсу,
    // если его всегда будут ждать "писатели".
    if (m_nWaitingWriters > 0) {
      // ресурс ждут "писатели", а они имеют приоритет перед "читателями"
      m_nActive = -1; // писатель получит доступ
      m_nWaitingWriters--; // одним ждущим "писателем" станет меньше
      hsem = &m_hsemWriters; // "писатели" ждут на этом семафоре
      // Примечание: семафор откроет путь только одному потоку-"писателю".
    } else if (m_nWaitingReaders > 0) {
      // ресурс ждут "читатели", а "писателей" нет
      m_nActive = m_nWaitingReaders; // все "читатели" получат доступ
      m_nWaitingReaders = 0; // ждущих "читателей" не останется
      hsem = &m_hsemReaders; // "читатели" ждут на этом семафоре
      lCount = m_nActive; // семафор откроет путь всем "читателям"
    } else {
      // ждущих потоков вообще нет
    }
  }
  // разрешаем другим потокам попытаться получить доступ для чтения или записи
  m_cs.unlock();

  if (hsem != nullptr) {
    // некоторые потоки следует пробудить
    hsem->release(lCount);
  }
}
